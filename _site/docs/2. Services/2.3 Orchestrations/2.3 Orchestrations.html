<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>2.3 Orchestration Services (Complex Higher Order Logic) | The Standard - Software Engineering Standard </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="2.3 Orchestration Services (Complex Higher Order Logic) | The Standard - Software Engineering Standard ">
      
      
      <link rel="icon" href="../../../images/favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../../toc.html">
      
      <meta name="docfx:rel" content="../../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/aminesayagh/thestandardway/blob/master/docs/2. Services/2.3 Orchestrations/2.3 Orchestrations.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.png" alt="The Standard">
            The Standard
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="23-orchestration-services-complex-higher-order-logic">2.3 Orchestration Services (Complex Higher Order Logic)</h1>

<h2 id="230-introduction">2.3.0 Introduction</h2>
<p>Orchestration services combine multiple foundation or processing services to perform a complex logical operation. Their main responsibilities are multi-entity logical operations and delegating the dependencies of those operations to downstream processing or foundation services.</p>
<p>Orchestration services' primary responsibility is encapsulating operations requiring two or three business entities.</p>
<pre><code class="lang-csharp">public async ValueTask&lt;LibraryCard&gt; CreateStudentLibraryCardAsync(LibraryCard libraryCard) =&gt;
TryCatch(async () =&gt;
{
    ValidateLibraryCard(libraryCard);

    await this.studentProcessingService
        .VerifyEnrolledStudentExistsAsync(libraryCard.StudentId);

    return await this.libraryCardProcessingService.CreateLibraryCardAsync(libraryCard);
});

</code></pre>
<p>In the above example, the <code>LibraryCardOrchestrationService</code> calls both the <code>StudentProcessingService</code> and <code>LibraryCardProcessingService</code> to perform a complex operation. First, we verify the student's existence and enrollment, then create the library card.</p>
<p>Creating a library card for a given student cannot be performed by simply calling the library card service because the library card service (processing or foundation) needs access to all the details about the student. Therefore, a combination logic is required to ensure that a proper flow is in place.</p>
<p>It's important to understand that orchestration services are only required if we need to combine multi-entity operations, which can be primitive or higher-order. In some architectures, orchestration services might not even exist. That's simply because some microservices might be merely responsible for applying validation logic and persisting and retrieving data from storage, no more or no less.</p>
<h2 id="231-on-the-map">2.3.1 On The Map</h2>
<p>Orchestration services are one of the core business logic components in any system, positioned between single entity services (such as processing or foundation) and advanced logic services such as coordination services, aggregation services, or simply exposers such as controllers, web components, or anything else. Here's a high-level overview of where orchestration services may live:</p>
<br>
    <p align="center">
        <img src="https://user-images.githubusercontent.com/1453985/118414675-e4fc8b80-b65a-11eb-91c8-94f67c6e68ed.png">
    </p>
<br>
<p>As shown above, Orchestration services have quite a few dependencies and consumers. They are the core engine of any software. On the right-hand side, you can see an orchestration service's dependencies. Since a processing service is optional based on whether a higher-order business logic is needed, orchestration services can combine multiple foundation services as well.</p>
<p>The existence of an Orchestration service warrants the presence of a Processing service. But that's only sometimes the case. In some situations, all orchestration services need to finalize a business flow to interact with primitive-level functionality.</p>
<p>However, an Orchestration service could have several consumers, such as coordination services (orchestrators of orchestrators), aggregation services, or an exposer. Exposers are like controllers, view services, UI components, or another foundation or processing service in case of putting messages back on a queue - which we will discuss further in our Standard.</p>
<h2 id="232-characteristics">2.3.2 Characteristics</h2>
<p>In general, orchestration services are concerned with combining single-entity primitive or higher-order business logic operations to execute a successful flow. But you can also think of them as the glue that ties multiple single-entity operations together.</p>
<h3 id="2320-language">2.3.2.0 Language</h3>
<p>Just like Processing services, the language used in Orchestration services defines the level of complexity and the capabilities it offers.
Orchestration services usually combine two or more primitive or higher-order operations from multiple single-entity services to execute a successful operation.</p>
<h4 id="23200-functions-language">2.3.2.0.0 Functions Language</h4>
<p>Orchestration services have a common characteristic regarding the language of their functions. Orchestration services are wholistic in most of the language of its function. You will see functions such as <code>NotifyAllAdmins</code> where the service pulls all users with an admin type and then calls a notification service.</p>
<p>Orchestration services offer functionality that inches closer to a business language than primitive technical operations. You may see almost an identical expression in a non-technical business requirement matching a function name in an orchestration service. The same pattern continues as one goes to higher and more advanced categories of services within a specific realm of business logic.</p>
<h4 id="23201-pass-through">2.3.2.0.1 Pass-Through</h4>
<p>Orchestration services can also be a pass-through for some operations. For instance, an orchestration service could allow an <code>AddStudentAsync</code> to be propagated through the service to unify the source of interactions with the system at the exposer's level. In this case, orchestration services will use the same terminology a processing or foundation service may use to propagate the operation.</p>
<h4 id="23202-class-level-language">2.3.2.0.2 Class-Level Language</h4>
<p>Orchestration services mainly combine multiple operations supporting a particular entity. So, if the primary entity is <code>Student</code> and the rest of the entities are just to support an operation mainly targeting a <code>Student</code> entity, then the name of the orchestration service would be <code>StudentOrchestrationService</code>.</p>
<p>Enforcement of naming conventions ensures that any orchestration service stays focused on a single entity's responsibility concerning multiple other supporting entities.</p>
<p>For instance, creating a library card requires the school enrollment of the student referenced in that library card. In this case, the Orchestration service name will reflect its primary entity, <code>LibraryCard</code>. Our orchestration service name would then be <code>LibraryCardOrchestrationService</code>.</p>
<p>The opposite is also true. If enrolling a student in a school has associated operations such as creating a library card, then, in this case, a <code>StudentOrchestrationService</code> must exist to create a <code>Student</code> and all other related entities.</p>
<p>The same idea applies to all exceptions created in an orchestration service, such as <code>StudentOrchestrationValidationException</code> and <code>StudentOrchestrationDependencyException</code>.</p>
<h3 id="2321-dependencies">2.3.2.1 Dependencies</h3>
<p>As we mentioned above, Orchestration services might have a more extensive range of dependencies, unlike Processing and Foundation services, because Processing services are optional. Therefore, Orchestration services may have dependencies ranging from foundation services or optional processing services to cross-cutting services such as logging or other utility brokers.</p>
<h4 id="23210-dependency-balance-florance-pattern">2.3.2.1.0 Dependency Balance (Florance Pattern)</h4>
<p>A fundamental rule governing the consistency and balance of orchestration services is the 'Florance Pattern', which dictates that any orchestration service may not combine dependencies from different categories of operation.</p>
<p>That means an Orchestration service cannot combine Foundation and Processing services. The dependencies have to be either all Processings or all Foundation services. That rule doesn't apply to utility broker dependencies, however.</p>
<p>Here's an example of an unbalanced orchestration service dependency:</p>
<br>
    <p align="center">
        <img src="https://user-images.githubusercontent.com/1453985/118415856-9e5e5f80-b661-11eb-96db-a541f89ccee7.png">
    </p>
<br>
<p>An additional processing service is required to give a pass-through to a lower-level foundation service to balance the architecture - applying 'Florance Pattern' for symmetry would turn our architecture into the following:</p>
<br>
    <p align="center">
        <img src="https://user-images.githubusercontent.com/1453985/118415965-33f9ef00-b662-11eb-8538-59e5c728d308.png">
    </p>
<br>
<p>Applying the 'Florance Pattern' might be very costly initially, including creating an entirely new processing service (or multiple) to balance the architecture. However, its benefits outweigh the cost from maintainability, readability, and pluggability perspectives.</p>
<h4 id="23211-two-three">2.3.2.1.1 Two-Three</h4>
<p>The 'Two-Three' rule is a complexity control rule. This rule dictates that an Orchestration service may have up to three or less than two Processing or Foundation services to run the orchestration. This rule, however, doesn't apply to utility brokers. Orchestration services may have a <code>DateTimeBroker</code> or a <code>LoggingBroker</code> without restriction. However, an orchestration service may not have an entity broker, such as a <code>StorageBroker</code> or a <code>QueueBroker</code>, which feeds directly into the core business layer of any service.</p>
<p>This rule, like most of the patterns and concepts in The Standard, is inspired by nature. You can see how the trees branch into twos and threes - the same thing for thunder, blood vessels, and so many other creations around, within, and above us follow the same pattern.</p>
<br>
    <p align="center">
        <img width="50%" src="https://raw.githubusercontent.com/hassanhabib/The-Standard/master/2.%20Services/2.3%20Orchestrations/Resources/2.3.2.1.1%20Two-Three.png">
    </p>
<br>
<p>A tree branches as it grows upwards but also in its very roots. And so is the case with Orchestration and Orchestration-Like services. They can branch further upwards, as I will explain here shortly, but also downwards through patterns like the Cul-De-Sac pattern.</p>
<p>The 'Two-Three' rule may require a layer of normalization to the categorical business function. Let's talk about the different mechanisms of normalizing orchestration services.</p>
<h5 id="232110-full-normalization">2.3.2.1.1.0 Full-Normalization</h5>
<p>There are frequently situations where the current architecture of any given orchestration service ends up with one orchestration service with three dependencies. A new entity processing or foundation service is required to complete an existing process.</p>
<p>For instance, let's say we have a <code>StudentContactOrchestrationService</code>, which has dependencies that provide primitive-level functionality for each student <code>Address</code>, <code>Email</code>, and <code>Phone</code>. Here's a visualization of that state:</p>
<br>
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120101834-f636a500-c0fc-11eb-968b-10ed9a60bac8.png">
    </p>
<br>
<p>Now, a new requirement, 'SocialMedia', is added to 'Student', to gather more contact information about how to reach a student. We can go into full-normalization mode by finding common ground that equally splits the contact information entities. For instance, we can break out regular contact information versus digital contact information as in <code>Address</code> and <code>Phone</code> versus <code>Email</code> and <code>SocialMedia</code>. This way, we split four dependencies into two, each for their orchestration services as follows:</p>
<br>
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120101983-c6d46800-c0fd-11eb-836a-496d191ef922.png">
    </p>
<br>
<p>In the figure above, we modified the existing <code>StudentContactOrchestrationService</code> into <code>StudentRegularContactOrchestrationService</code> and removed one of its dependencies on the <code>EmailService</code>.</p>
<p>Additionally, we created a new <code>StudentDigitalContactOrchestrationService</code> to have two dependencies on the existing <code>EmailService</code> and the latest <code>SocialMediaService</code>. Consequently, we need an advanced business logic layer, like a coordination service, to provide student contact information to upstream consumers.</p>
<h5 id="232111-semi-normalization">2.3.2.1.1.1 Semi-Normalization</h5>
<p>Normalization is more complex than the example above, especially when a core entity has to exist before creating or filling in additional information about related entities.</p>
<p>For instance, let's say we have a <code>StudentRegistrationOrchestrationService</code> which relies on <code>StudentProcessingService</code>, <code>LibraryCardProcessingService</code>, and <code>BookProcessingService</code> as follows:</p>
<br>
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120099527-c41f4600-c0f0-11eb-8702-1439f966d9dc.png">
    </p>
<br>
<p>But now, we need a new service called' ImmunizationProcessingService' to handle students' immunization records. We need all four services, but we already have a <code>StudentRegistrationOrchestrationService</code> that has three dependencies. At this point, a semi-normalization is required for the re-balancing of the architecture to honor the 'Two-Three' rule and eventually control the complexity.</p>
<br>
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120100296-ea46e500-c0f4-11eb-888a-ed6668e9ffdb.png">
    </p>
<br>
<p>In this case, a further normalization or a split is required to re-balance the architecture. We must think conceptually about the common ground between the primitive entities in a student registration process. Student requirements contain identity, health, and materials. We can, in this scenario, combine <code>LibraryCard</code> and <code>Book</code> under the same orchestration service as books and libraries are somewhat related. So we have <code>StudentLibraryOrchestrationService,</code> and for the other service, we would have <code>StudentHealthOrchestrationService</code> as follows:</p>
 <br>
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120100597-68f05200-c0f6-11eb-9ccc-ae1c963f6de5.png">
    </p>
 <br>
<p>To complete the registration flow with a new model, a coordination service must pass in advanced business logic to combine these entities. But more importantly, you will notice that each orchestration service has a redundant dependency of <code>StudentProcessingService</code> to ensure no virtual dependency on any other orchestration service,  creating/providing a student record exists.</p>
<p>Virtual dependencies are very tricky. It's a hidden connection between two services of any category where one service implicitly assumes that a particular entity will be created and present. Virtual dependencies are very dangerous and threaten the proper autonomy of any service. Detecting virtual dependencies early in the design and development process could be a daunting but necessary task to ensure a clean, Standardized architecture is in place.</p>
<p>Just like model changes require database structure migrations and additional logic and validations, a new requirement for a new entity might require restructuring an existing architecture or extending it to a new version, depending on which stage the system receives these new requirements.</p>
<p>Adding another dependency to an existing orchestration service may be very enticing - but that's where the system starts to diverge from 'The Standard'. And that's when the system begins to become an unmaintainable legacy system. But more importantly, this scenario tests the design principles and standards of craftsmanship of the engineers involved in designing and developing the system.</p>
<h5 id="232112-no-normalization">2.3.2.1.1.2 No-Normalization</h5>
<p>Everything, everywhere, is somehow connected. Yet, there are scenarios where higher levels of normalization are challenging to achieve. Sometimes, it might be incomprehensible for the mind to group multiple services under one orchestration service.</p>
<p>Because it's hard for me to come up with an example for multiple entities that have no connection to each other, it couldn't exist. I'm going to rely on some fictional entities to visualize a problem. So, let's assume there are <code>AService</code> and <code>BService</code> orchestrated together with an <code>XService</code>. The existence of <code>XService</code> is important to ensure that both <code>A</code> and <code>B</code> can be created with an assurance that a core entity <code>X</code> does exist.</p>
<p>Now, let's say a new service, <code>CService</code>, must be added to the mix to complete the existing flow. So, now we have four different dependencies under one orchestration service, and a split is mandatory. Since there's no relationship whatsoever between <code>A</code>, <code>B</code>, and <code>C</code>, a 'No-Normalization' approach becomes the only option to realize a new design as follows:</p>
 <br>
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120102975-4d8b4400-c102-11eb-9582-6f95d17227e7.png">
    </p>
 <br>
<p>The above primitive services will be orchestrated with a core service, <code>X</code>, and then gathered under a coordination service. This case above is the worst-case scenario, where normalization of any size is impossible. Note that the author of this Standard couldn't come up with a realistic example unlike any others to show you how rare it is to run into that situation, so let a 'No-Normalization' approach be your very last solution if you run out of options.</p>
<h5 id="232113-meaningful-breakdown">2.3.2.1.1.3 Meaningful Breakdown</h5>
<p>Regardless of the type of normalization you follow, you must ensure that your grouped services represent a common meaning. For instance, putting together a <code>StudentProcessingService</code> and <code>LibraryProcessingService</code> must require a functional commonality. An excellent example of that would be <code>StudentRegistrationOrchestrationService</code>. The registration process requires adding a new student record and creating a library card for that student.</p>
<p>Implementing orchestration services without an intersection between two or three entities per operation defeats the whole purpose of having an orchestration service. This condition is satisfied if at least one intersection between two entities has occurred. An orchestration service may have other 'Pass-Through' operations where we propagate certain routines from their processing or foundation origins if they match the same contract.</p>
<p>Here's an example:</p>
<pre><code class="lang-csharp">public class StudentOrchestrationService
{
    public async ValueTask&lt;Student&gt; RegisterStudentAsync(Student student)
    {
        Student addedStudent =
            await this.studentProcessingService.AddStudentAsync(student);
    
        LibraryCard libraryCard = 
            await this.libraryCardPorcessingService.AddLibraryCardAsync(
                addedStudent.Id);

        return addedStudent;
    }

    public async ValueTask&lt;Student&gt; ModifyStudentAsync(Student student) =&gt;
        await this.studentProcessingService.ModifyStudentAsync(student);
}
</code></pre>
<p>In the example above, our <code>StudentOrchestrationService</code> had an orchestration routine that combined adding a student and creating a library card for that student. It also offers a 'Pass-Through' function for a low-level processing service routine to modify a student.</p>
<p>'Pass-Through' routines must have the same contract as the other routines in any orchestration service. Our 'Pure Contract' principle dictates that any service should allow the same contract as input and output or primitive types.</p>
<h3 id="2322-contracts">2.3.2.2 Contracts</h3>
<p>Orchestration services may combine two or three different entities and their operations to achieve a higher business logic. There are two scenarios for contract/models for orchestration services: One that stays true to the primary entity's purpose and one that is complex - a combinator orchestration service that tries to expose its inner target entities explicitly.</p>
<p>Let's talk about these two scenarios in detail.</p>
<h4 id="23220-physical-contracts">2.3.2.2.0 Physical Contracts</h4>
<p>Some orchestration services are still single-purposed, even though they may combine two or three other higher-order routines from multiple entities. For instance, an orchestration service that reacts to messages from some queue and persists in these messages is a single-purposed and single-entity orchestration service.</p>
<p>Let's take a look at this code snippet:</p>
<pre><code class="lang-csharp">
public class StudentOrchestrationService
{
    private readonly IStudentEventProcessingService studentEventProcessingService;
    private readonly IStudentProcessingService studentProcessingService;

    public StudentOrchestrationService(
        IStudentEventProcessingService studentEventProcessingService,
        IStudentProcessingService studentProcessingService)
    {
        this.studentEventProcessingService = studentEventProcessingService;
        this.studentProcessingService = studentProcessingService;
        ListenToEvents();
    }

    public void ListenToEvents() =&gt;
        this.studentEventService.ListenToEvent(UpsertStudentAsync);

    public async ValueTask&lt;Student&gt; UpsertStudentAsync(Student student)
    {
        ...
        await this.studentProcessingService.UpsertStudentAsync(student);

        ...
    }
}
</code></pre>
<p>In the above example, the orchestration service still exposes functionality that honors the physical model <code>Student</code> and internally communicates with several services that may provide completely different models. These are the scenarios where a single entity has a primary purpose, and all other services are supporting services to ensure a successful flow for that entity.</p>
<p>In our example, the orchestration services listen to a queue for new student messages and use that event to persist any incoming new students in the system. So, the physical contract <code>Student</code> is the same language the orchestration service explicitly uses as a model to communicate with upper stream services/exposers or others.</p>
<p>However, there are other scenarios in which a single entity is not the only purpose/target for an orchestration service. Let's discuss that in detail.</p>
<h4 id="23221-virtual-contracts">2.3.2.2.1 Virtual Contracts</h4>
<p>In some scenarios, an orchestration service may be required to create non-physical contracts to complete a particular operation. For instance, consider an orchestration service required to persist a social media post containing a picture. The requirement is to persist the picture in one database and the actual post (comments, authors, and others) in a different database table in a relational model.</p>
<p>The incoming model might be significantly different from the actual physical models. Let's see what that would look like in the real world.</p>
<p>Consider having this model:</p>
<pre><code class="lang-csharp">public class MediaPost
{
    public Guid Id {get; set;}
    public string Content {get; set;}
    public DateTimeOffset Date {get; set;}
    public IEnumerable&lt;string&gt; Base64Images {get; set;}
}
</code></pre>
<p>The above contract, <code>MediaPost,</code> contains two separate physical entities. The first is the actual post, including the <code>Id</code>, <code>Content</code>, and <code>Date</code>, and the second is the list of images attached to that post.</p>
<p>Here's how an orchestration service would react to this incoming virtual model:</p>
<pre><code class="lang-csharp">public async ValueTask&lt;MediaPost&gt; SubmitMediaPostAsync(MediaPost mediaPost)
{
    ...

    Post post = MapToPost(mediaPost);
    List&lt;Media&gt; medias = MapToMedias(mediaPost);

    Post addedPost =
        await this.postProcessingService.AddPostAsync(post);
    
    List&lt;Medias&gt; addedMedias = 
        await this.mediaProcessingService.AddMediasAsync(medias);

    return MapToMediaPost(addedPost, addedMedias); 
}

public Post MapToPost(MediaPost mediaPost)
{
    return new Post
    {
        Id = mediaPost.Id,
        Content = mediaPost.Content,
        CreatedDate = mediaPost.Date,
        UpdatedDate = mediaPost.Date
    };
}

public List&lt;Media&gt; MapToMedias(MediaPost mediaPost)
{
    return mediaPost.Base64Images.Select(image =&gt;
        new Media
        {
            Id = Guid.NewGuid(),
            PostId = mediaPost.Id,
            Image = image,
            CreatedDate = mediaPost.Date,
            UpdatedDate = mediaPost.Date
        });
}
</code></pre>
<p>The above code snippet shows the orchestration service deconstructing a given virtual model/contract, <code>MediaPost</code>, into two physical models. Each one has its separate processing service that handles its persistence. There are scenarios where the virtual model gets deconstructed into one single model with additional details used for validation and verification with downstream processing or foundation services.</p>
<p>In hybrid situations, the incoming virtual model may have nested physical models, which we can only allow with virtual models. Physical models shall always stay anemic (contains no routines or constructors) and flat (contains no nested models) to control complexity and focus responsibility.</p>
<p>In summary, Orchestration services may create their contracts, which may be physical or virtual. A virtual contract may be a combination of one or many physical (or nested virtual) contracts or simply have its own flat design in terms of properties.</p>
<h3 id="2322-cul-de-sac">2.3.2.2 Cul-De-Sac</h3>
<p>Sometimes, Orchestration services and their equivalent (coordination, management, etc.) may not need an exposer component (controller, for instance). That's because these services may listen to specific events and communicate them back into a Processing or a Foundation service at the same level where the event started or was received.</p>
<p>For example, incoming messages can be received from a subscription to an event service or a queue. In this case, the input for these services isn't necessarily through an exposer component anymore. Imagine building a simple application that gets notified with messages from a queue and then maps these messages into some local model to persist it in storage. In this case, the orchestration service would look something like the following:</p>
 <br>
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/144501231-11ea13c9-81fa-4730-8840-a891a1d9edde.png">
    </p>
 <br>
<p>The <code>StudentEventOrchestrationService</code> listens to messages for new students and immediately converts them into models that can be persisted in the database.</p>
<p>Here's an example:</p>
<p>Let's start with a unit test for this pattern as follows:</p>
<pre><code class="lang-csharp">[Fact]
private void ShouldListenToProfileEvents()
{
   // given . when
   this.profileEventOrchestrationService.ListenToProfileEvents();

   // then
   this.profileEventServiceMock.Verify(service =&gt;
       service.ListenToProfileEvent(
           this.profileEventOrchestrationService.ProcessProfileEventAsync),
               Times.Once);

   this.profileEventService.VerifyNoOtherCalls();
   this.profileServiceMock.VerifyNoOtherCalls();
   this.loggingBrokerMock.VerifyNoOtherCalls();
}

[Fact]
private async Task ShouldAddProfileAsync()
{
   // given
   ProfileEvent randomProfileEvent =
       CreateRandomProfileEvent();

   ProfileEvent inputProfileEvent =
       randomProfileEvent;

   this.profileServiceMock.Setup(service =&gt;
       service.AddProfileAsync(inputProfileEvent.Profile));

   // when
   await this.profileEventOrchestrationService
       .ProcessProfileEventAsync(inputProfileEvent);

   // then
   this.profileServiceMock.Verify(service =&gt;
       service.AddProfileAsync(inputProfileEvent.Profile),
           Times.Once);

   this.profileServiceMock.VerifyNoOtherCalls();
   this.loggingBrokerMock.VerifyNoOtherCalls();
   this.profileEventServiceMock.VerifyNoOtherCalls();
}
</code></pre>
<p>The test here indicates that an event listening has to occur first, and then persistence logic in the student service must match the outcome of mapping an incoming message to a given student.</p>
<p>Let's make this test pass.</p>
<pre><code class="lang-csharp">public partial class ProfileEventOrchestrationService : IProfileEventOrchestrationService
{
   private readonly IProfileEventService profileEventService;
   private readonly IProfileService profileService;
   private readonly ILoggingBroker loggingBroker;

   public ProfileEventOrchestrationService(
       IProfileEventProcessingService profileEventService,
       IProfileProcessingService profileService,
       ILoggingBroker loggingBroker)
   {
       this.profileEventService = profileEventService;
       this.profileService = profileService;
       this.loggingBroker = loggingBroker;
   }

   public void ListenToProfileEvents() =&gt;
   TryCatch(() =&gt;
   {
       this.profileEventService.ListenToProfileEvent(
           ProcessProfileEventAsync);
   });

   public ValueTask ProcessProfileEventAsync(ProfileEvent profileEvent) =&gt;
   TryCatch(async () =&gt;
   {
       ...

       await this.profileService.AddProfileAsync(profileEvent.Profile);
   });
}
</code></pre>
<p>In the above example, the Orchestration service constructor subscribes to the events that would come from the <code>ProfileEventProcessingService</code>. When an event occurs, the orchestration service calls the <code>ProcessProfileEventAsync</code> function to persist the incoming student into the database through a foundation or a processing service at the same level as the event service.</p>
<p>This pattern or characteristic is called the Cul-De-Sac. An incoming message will turn and head in a different direction for a different dependency. This pattern is typical in large enterprise-level applications where eventual consistency is incorporated to ensure the system can scale and become resilient under heavy consumption. This pattern also prevents malicious attacks against your API endpoints since it allows processing queue messages or events whenever the service is ready to process them. We will discuss the details in 'The Standard Architecture.</p>
<h2 id="233-responsibilities">2.3.3 Responsibilities</h2>
<p>Orchestration services provide advanced business logic. It orchestrates multiple flows for multiple entities/models to complete a single flow. Let's discuss in detail what these responsibilities are:</p>
<h3 id="2330-advanced-logic">2.3.3.0 Advanced Logic</h3>
<p>Orchestration services can only exist by combining multiple routines from multiple entities. These entities may differ in nature but share a standard flow or purpose. For instance, a <code>LibraryCard</code> model fundamentally differs from a <code>Student</code> model. However, they both share a common purpose regarding the student registration process. Adding a student record is required to register a student, but assigning a library card to that student is required for a successful student registration process.</p>
<p>Orchestration services ensure the correct routines for each entity are integrated and called in the proper order. Additionally, orchestration services are responsible for rolling back a failing operation. These three aspects constitute an orchestration effort across multiple routines, entities, or contracts.</p>
<p>Let's talk about those in detail.</p>
<h4 id="23300-flow-combinations">2.3.3.0.0 Flow Combinations</h4>
<p>We spoke earlier about orchestration services combining multiple routines to achieve a common purpose or a single flow. This aspect of orchestration services can serve as both a fundamental characteristic and a responsibility. An orchestration service without at least one routine combining two or three entities is not considered an orchestration. Integrating multiple services without a common purpose is a better-fit definition for aggregation services, which we will discuss later in this services chapter.</p>
<p>However, within the flow combination comes the unification of the contract. I call it mapping and branching. Mapping an incoming model into multiple lower-stream service models and then branching the responsibility across these services.</p>
<p>Just like the previous services, during their flow combination, Orchestration services are responsible for ensuring the purity of the exposed input and output contracts, which becomes a bit more complex when combining multiple models. Orchestration services will continue to be responsible for mapping incoming contracts to their respective downstream services. They will also map back the results from these services into the unified model.</p>
<p>Let's bring back a previous code snippet to illustrate that aspect:</p>
<pre><code class="lang-csharp">public async ValueTask&lt;MediaPost&gt; SubmitMediaPostAsync(MediaPost mediaPost)
{
    ...

    Post post = MapToPost(mediaPost);
    List&lt;Media&gt; medias = MapToMedias(mediaPost);

    Post addedPost =
        await this.postProcessingService.AddPostAsync(post);
    
    List&lt;Medias&gt; addedMedias = 
        await this.mediaProcessingService.AddMediasAsync(medias);

    return MapToMediaPost(addedPost, addedMedias); 
}

private Post MapToPost(MediaPost mediaPost)
{
    return new Post
    {
        Id = mediaPost.Id,
        Content = mediaPost.Content,
        CreatedDate = mediaPost.Date,
        UpdatedDate = mediaPost.Date
    };
}

private List&lt;Media&gt; MapToMedias(MediaPost mediaPost)
{
    return mediaPost.Base64Images.Select(image =&gt;
        new Media
        {
            Id = Guid.NewGuid(),
            PostId = mediaPost.Id,
            Image = image,
            CreatedDate = mediaPost.Date,
            UpdatedDate = mediaPost.Date
        });
}

private MediaPost MapToMediaPost(Post post, List&lt;Media&gt; medias)
{
    return new MediaPost
    {
        Id = post.Id,
        Content = post.Content,
        Date = post.CreatedDate,
        Base64Images = medias.Select(media =&gt; media.Image)
    }
}
</code></pre>
<p>As you can see in the above example, the mapping and branching don't just happen on the way in. But a reverse action has to be taken on the way out. It violates The Standard to return the same input object that was passed in. That takes away any visibility on potential changes to the incoming request during persistence. The duplex mapping should substitute the need to dereference the incoming request to ensure no unexpected internal changes have occurred.</p>
<p>Note that breaking out the mapping logic into its own aspect/partial class file is also recommended�something like <code>StudentOrchestrationService.Mappings.cs</code>�to ensure the only thing left is orchestration's business logic.</p>
<h4 id="23301-call-order">2.3.3.0.1 Call Order</h4>
<p>Calling routines in the correct order can be crucial to any orchestration process. For instance, a library card cannot be created unless a student record is created first. Enforcing the order here can be divided into two different types. Let's discuss those here for a bit.</p>
<h5 id="233010-natural-order">2.3.3.0.1.0 Natural Order</h5>
<p>The natural order here refers to specific flows that cannot be executed unless a prerequisite of input parameters is retrieved or persisted. For instance, imagine a situation where a library card cannot be created unless a student's unique identifier is retrieved first. In this case, we don't have to worry about testing that certain routines were called in the correct order because it comes naturally with the flow.</p>
<p>Here's a code example of this situation:</p>
<pre><code class="lang-csharp">public async ValueTask&lt;LibraryCard&gt; CreateLibraryCardAsync(LibraryCard libraryCard)
{
    Student student = await this.studentProcessingService
        .RetrieveStudentByIdAsync(libraryCard.StudentId));

    return await this.libraryCardProcessingService
        .CreateLibraryCardAsync(libraryCard, student.Name);
}
</code></pre>
<p>In the example above, having a student <code>Name</code> is a requirement to create a library card. Therefore, the orchestration of order here comes naturally as part of the flow without additional effort.</p>
<p>Let's talk about the second type of order - Enforced Order.</p>
<h5 id="233011-enforced-order">2.3.3.0.1.1 Enforced Order</h5>
<p>Imagine the same example above, but instead of the library card requiring a student name, it just needs the student <code>Id</code> already enclosed in the incoming request model. Something like this:</p>
<pre><code class="lang-csharp">public async ValueTask&lt;LibraryCard&gt; CreateLibraryCardAsync(LibraryCard libraryCard)
{
    await this.studentProcessingService.VerifyEnlistedStudentExistAsync(
        libraryCard.StudentId);

    return await this.libraryCardProcessingService.CreateLibraryCardAsync(libraryCard);
}
</code></pre>
<p>Ensuring a verified enrolled student exists before creating a library card might become a challenge because there is no dependency between the return value of one routine and the input parameters of the next. In other words, the <code>VerifyEnlistedStudentExistAsync</code> function returns nothing that the <code>CreateLibraryCardAsync</code> function cares about in terms of input parameters.</p>
<p>In this case, an enforced type of order must be implemented through unit tests. A unit test for this routine would require verifying not just that the dependency has been called with the correct parameters but also that they are called in the correct <em>order</em> let's take a look at how that would be implemented:</p>
<pre><code class="lang-csharp">[Fact]
private async Task ShouldCreateLibraryCardAsync()
{
    // given
    Student someStudent = CreateRandomStudent();
    LibraryCard randomLibraryCard = CreateRandomLibraryCard();
    LibraryCard inputLibraryCard = randomLibraryCard;
    LibraryCard createdLibraryCard = inputLibraryCard;
    LibraryCard expectedLibraryCard = inputLibraryCard.DeepClone();
    Guid studentId = inputLibraryCard.StudentId;
    var mockSequence = new MockSequence();

    this.studentProcessingServiceMock.InSequence(mockSequence).Setup(service =&gt;
        service.VerifyEnlistedStudentExistAsync(studentId))
            .Returns(someStudent);

    this.libraryCardProcessingServiceMock.InSequence(mockSequence).Setup(service =&gt;
        service.CreateLibraryCardAsync(inputLibraryCard))
            .ReturnsAsync(createdLibraryCard);

    // when
    LibraryCard actualLibraryCard = await this.libraryCardOrchestrationService
        .CreateLibraryCardAsync(inputLibraryCard);

    // then
    actualLibraryCard.Should().BeEquivalentTo(expectedLibraryCard);

    this.studentProcessingServiceMock.Verify(service =&gt;
        service.VerifyEnlistedStudentExistAsync(studentId),
            Times.Once);

    this.libraryCardProcessingServiceMock.Verify(service =&gt;
        service.CreateLibraryCardAsync(inputLibraryCard),
            Times.Once);

    this.studentProcessingServiceMock.VerifyNoOtherCalls();
    this.libraryCardProcessingServiceMock.VerifyNoOtherCalls();
    this.loggingBrokerMock.VerifyNoOtherCalls();
}

</code></pre>
<p>In the example above, the mock framework is being used to ensure a certain order is enforced when calling these dependencies. This way, we enforce a certain implementation within any given method to ensure that non-naturally connected dependencies are sequentially called in the intended order.</p>
<p>It's more likely that the type of ordering leans more towards enforced than natural when orchestration services reach the maximum number of dependencies.</p>
<h4 id="23302-exceptions-mapping-wrapping--unwrapping">2.3.3.0.2 Exceptions Mapping (Wrapping &amp; Unwrapping)</h4>
<p>This responsibility is very similar to flow combinations. Except in this case, orchestration services unify all the exceptions that may occur from any dependencies into one unified categorical exception model. Let's start with an illustration of what that mapping may look like:</p>
 <br>
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/145294325-0818a2dd-a017-43af-b1f0-fa5c93a9218c.png">
    </p>
 <br>
<p>In the illustration above, you will notice that validation and dependency validation exceptions, thrown from downstream dependency services, map into one unified dependency exception at the orchestration level. This practice allows upstream consumers of that same orchestration service to determine the next course of action based on one categorical exception type instead of four, or in the case of three dependencies, it would be six categorical dependencies.</p>
<p>Let's start with a failing test to materialize our idea here:</p>
<pre><code class="lang-csharp">public static TheoryData DependencyValidationExceptions()
{
    string exceptionMessage = GetRandomMessage();
    var innerException = new Xeption(exceptionMessage);

    var studentValidationException =
        new StudentValidationException(
            message: &quot;Student validation error occurred, fix errors and try again.&quot;,
            innerException);

    var studentDependencyValidationException =
        new StudentDependencyValidationException(
            message: &quot;Student dependency validation error occurred, fix errors and try again.&quot;,
            innerException);

    var libraryCardValidationException =
        new LibraryCardValidationException(
            message: &quot;Library card validation error occurred, fix errors and try again.&quot;,
            innerException);

    var libraryCardDependencyValidationException =
        new LibraryCardDependencyValidationException(
            message: &quot;Library card dependency validation error occurred, fix errors and try again.&quot;,
            innerException);

    return new TheoryData&lt;Xeption&gt;
    {
        studentValidationException,
        studentDependencyValidationException,
        libraryCardValidationException,
        libraryCardDependencyValidationException
    };
}


[Theory]
[MemberData(nameof(DependencyValidationExceptions))]
private async Task ShouldThrowDependencyValidationExceptionOnCreateIfDependencyValidationErrorOccursAndLogItAsync(
    Xeption dependencyValidationException)
{
    // given
    Student someStudent = CreateRandomStudent();

    var expectedStudentOrchestrationDependencyValidationException =
        new StudentOrchestrationDependencyValidationException(
            message: &quot;Student dependency validation error occurred, fix errors and try again&quot;,
            dependencyValidationException.InnerException as Xeption);

    this.studentServiceMock.Setup(service =&gt;
        service.AddStudentAsync(It.IsAny&lt;Student&gt;()))
            .ThrowsAsync(dependencyValidationException);

    // when
    ValueTask&lt;Student&gt; addStudentTask =
        await this.studentOrchestrationService.AddStudentAsync(someStudent);

    StudentOrchestrationDependencyValidationException
        actualStudentOrchestrationDependencyValidationException =
                await Assert.ThrowsAsync&lt;StudentOrchestrationDependencyValidationException&gt;(
                    addStudentTask.AsTask);

    // then
    actualStudentOrchestrationDependencyValidationException.Should()
        .BeEquivalentTo(expectedStudentOrchestrationDependencyValidationException);

    this.studentServiceMock.Verify(service =&gt;
        service.AddStudentAsync(It.IsAny&lt;Student&gt;()),
            Times.Once);

    this.loggingBrokerMock.Verify(broker =&gt;
        broker.LogError(It.Is(SameExceptionAs(
            expectedStudentOrchestrationDependencyValidationException))),
                Times.Once);

    this.libraryCardServiceMock.Verify(service =&gt;
        service.AddLibraryCardAsync(It.IsAny&lt;Guid&gt;()),
            Times.Once);

    this.studentServiceMock.VerifyNoOtherCalls();
    this.loggingBrokerMock.VerifyNoOtherCalls();
    this.libraryCardServiceMock.VerifyNoOtherCalls();
}
</code></pre>
<p>Above, we verify that any of our four exception types are mapped into a <code>StudentOrchestrationDependencyValidationException</code>. We maintain the original localized exception as an inner exception. But we unwrap the categorical exception at this level to keep the original issue as we go upstream.</p>
<p>These exceptions are mapped under a dependency validation exception because they originate from a dependency or a dependency of a dependency downstream. For instance, if a storage broker throws an exception, it is a dependency validation (something like <code>DuplicateKeyException</code>). The broker-neighboring service would map that into a localized <code>StudentAlreadyExistException</code> and then wrap that exception in a categorical exception of type <code>StudentDependencyValidationException</code>. When that exception propagates upstream to Processing or an Orchestration service, we lose the categorical exception as we have already captured it under the proper scope of mapping. Then, we continue to embed that very localized exception under the current service dependency validation exception.</p>
<p>Let's try to make this test pass:</p>
<pre><code class="lang-csharp">public partial class StudentOrchestrationService
{
    private delegate ValueTask&lt;Student&gt; ReturningStudentFunction();

    private async ValueTask&lt;Student&gt; TryCatch(ReturningStudentFunction returningStudentFunction)
    {
        try
        {
            return await returningStudentFunction();
        }
        catch (StudentValidationException studentValidationException)
        {
            throw await CreateAndLogDependencyValidationExceptionAsync(studentValidationException);
        }
        catch (StudentDependencyValidationException studentDependencyValidationException)
        {
            throw await CreateAndLogDependencyValidationExceptionAsync(studentDependencyValidationException);
        }
        catch (LibraryCardValidationException libraryCardValidationException)
        {
            throw await CreateAndLogDependencyValidationExceptionAsync(libraryCardValidationException);
        }
        catch (LibraryCardDependencyValidationException libraryCardDependencyValidationException)
        {
            throw await CreateAndLogDependencyValidationExceptionAsync(libraryCardDependencyValidationException);
        }
    }

    private async ValueTask&lt;StudentOrchestrationDependencyValidationException&gt;
        CreateAndLogDependencyValidationExceptionAsync(Xeption exception)
    {
        var studentOrchestrationDependencyValidationException =
            new StudentOrchestrationDependencyValidationException(
                message: &quot;Student dependency validation error occurred, fix errors and try again&quot;,
                exception.innerException as Xeption);

        await this.loggingBroker.LogErrorAsync(studentOrchestrationDependencyValidationException);

        return studentOrchestrationDependencyValidationException;
    }
}
</code></pre>
<p>Now we can use the <code>TryCatch</code> as follows:</p>
<pre><code class="lang-csharp">public async ValueTask&lt;Student&gt; AddStudentAsync(Student student) =&gt;
TryCatch(async () =&gt; 
{
    ...
    Student addedStudent = await this.studentService.AddStudentAsync(student);
    LibraryCard libraryCard = await this.libraryCard.AddLibraryCard(addedStudent.Id);

    return addedStudent;  
});
</code></pre>
<p>In the implementation, you can see that we mapped all four different types of external downstream services validation exceptions into one categorical exception and then maintained the inner exception for each one.</p>
<p>The same rule applies to dependency exceptions. Dependency exceptions can be both Service and Dependency exceptions from downstream services. For instance, in the above example, calling a student service may produce <code>StudentDependencyException</code> and <code>StudentServiceException</code>. These categorical exceptions will be unwrapped from their categorical layer and have their local layer wrapped in one unified new orchestration-level categorical exception under <code>StudentOrchestrationDependencyException</code>. The same applies to all other dependency categorical exceptions like <code>LibraryCardDependencyException</code> and <code>LibraryCardServiceException</code>.</p>
<p>It's crucial to unwrap and wrap localized exceptions from downstream services with categorical exceptions at the current service layer to ensure consistency with the Exposers layer. These exceptions can be easily handled and mapped into whatever the nature of the exposer component dictates. In the case of an Exposer component of type API Controller, the mapping would produce HTTP Status Codes. In the case of UI Exposer components, it would map to text meaningful to end users.</p>
<p>We will discuss further upstream in this Standard when to expose localized inner exceptions details where end-users are not required to take any action exclusive to dependency and service level exceptions.</p>
<h2 id="234-variations">2.3.4 Variations</h2>
<p>Orchestration services vary depending on their position in the overall low-level architecture. For instance, an orchestration service that relies on downstream orchestration services is called a Coordination service. An Orchestration service working with multiple Coordination services as dependencies is called a Management Service. These variants are Orchestration services with uber-level business logic.</p>
<h3 id="2340-variants-levels">2.3.4.0 Variants Levels</h3>
<p>Let's take a look at the possible variants for orchestration services and where they would be positioned:</p>
 <br>
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147461598-e7fe6b48-976a-4787-bd97-11e7faf131ee.png">
    </p>
 <br>
<p>In my personal experience, I've rarely had to resolve to an Uber Management service. The limitation here in terms of dependencies and variations of orchestration-like services is to help engineers rethink the complexity of their logic. But admittedly, there are situations where complexity is an absolute necessity. Therefore, Uber Management services exist as an option.</p>
<p>The following table should guide the process of developing variants of orchestration services based on the level:</p>
<table>
<thead>
<tr>
<th>Variant</th>
<th>Dependencies</th>
<th>Consumers</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td>Orchestration Services</td>
<td>Foundation or Processing Services</td>
<td>Coordination Services</td>
<td>Low</td>
</tr>
<tr>
<td>Coordination Services</td>
<td>Orchestration Services</td>
<td>Management Services</td>
<td>Medium</td>
</tr>
<tr>
<td>Management Services</td>
<td>Coordination Services</td>
<td>Uber Management Services</td>
<td>High</td>
</tr>
<tr>
<td>Uber Management Services</td>
<td>Management Services</td>
<td>Aggregation, Views or Exposer Components</td>
<td>Very High</td>
</tr>
</tbody>
</table>
<p>Working beyond Uber Management services in an orchestration manner would require a more profound discussion and a serious consideration of the overall architecture. Future versions of The Standard might be able to address this issue in what I call &quot;The Lake House,&quot; but that is outside of the scope of this version of The Standard.</p>
<h3 id="2341-unit-of-work">2.3.4.1 Unit of Work</h3>
<p>With the variations of orchestration services, I recommend staying true to the concept of unit of work. Every request can do one thing and one thing only, including its prerequisites. For instance, if you need to register a student in a school, you may also need to add a guardian, contact information, and other details. Eventing these actions can significantly decrease the complexity of the flow and lower the risk of failures in downstream services.</p>
<p>Here's a visualization for a complex single-threaded approach:</p>
 <br>
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147462984-84e6dabd-bf27-413a-8e79-2659a24c37c0.png">
    </p>
 <br>
<p>The solution above is a working solution for registering a student. We needed to include guardian information, library cards, classes, etc. These dependencies can be broken down into eventing, allowing other services to pick up where the single-threaded services leave off to continue the registration process. Something like this:</p>
  <br>
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147463233-466a055f-ce95-4911-92cd-7b173b2a37df.png">
    </p>
  <br>
<p>Above, the incoming request is turned into events, each of which would notify its orchestration services in a cul-de-sac pattern, as discussed in section 2.3.2.2. That means that a single thread is no longer responsible for the success of each dependency in the system. Instead, every event-listening broker would handle its process in a simplified way.</p>
<p>This approach does not guarantee an immediate response of success or failure to the requestor. It's an eventual consistency pattern where the client would get an <code>Accepted</code> message or its equivalent based on the communication protocol to let them know that a process has started. Still, results are only guaranteed once all event logic has been executed.</p>
<p>Note that we can add an extra layer of resiliency to these events by temporarily storing them in Queue-like components or memory-based temporary storages; depending on the criticality of the business.</p>
<p>However, an eventual consistency approach is only sometimes a good solution if the client on the other side is waiting for a response, especially in critical situations where an immediate response is required. One solution to this problem is Fire-n-Observe queues, which we will discuss in the future version of The Standard.</p>
<p>[*] <a href="https://www.youtube.com/watch?v=OP6HcIpXduE">Introduction to Orchestration Services</a></p>
<p>[*] <a href="https://www.youtube.com/watch?v=C8Sm1kSKF1o">Cul-De-Sac Pattern for Orchestration Services</a></p>
<p>[*] <a href="https://www.youtube.com/watch?v=8KZIw_IJC0U">Cul-De-Sac Pattern for Coordination Services</a></p>

</article>


        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
